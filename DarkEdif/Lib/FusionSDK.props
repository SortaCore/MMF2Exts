<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<!-- If displayed in VS -->
		<_PropertySheetDisplayName>Fusion SDK Properties</_PropertySheetDisplayName>
	</PropertyGroup>
	<PropertyGroup Label="UserMacros">
		<!-- MultiPlatform targeting -->
		<_TargetPlat>$(TargetPlatformIdentifier)</_TargetPlat>
		<_TargetPlat Condition="$(_TargetPlat)==''">Windows</_TargetPlat>
		<ExtName>$(ProjectName.Split('.')[0])</ExtName>
		<TargetArch Condition="'$(_TargetPlat)'!='iOS'">x86</TargetArch>
		<TargetArch Condition="'$(_TargetPlat)'=='Android' AND '$(TargetArchAbi)'!=''">$(TargetArchAbi)</TargetArch>
		<TargetArch Condition="'$(_TargetPlat)'=='iOS'">$(PlatformNativeArch)</TargetArch>
		<TargetArch Condition="'$(_TargetPlat)'=='iOS' AND '$(Platform)'=='Win32'">i386</TargetArch>
		<TargetArch Condition="'$(_TargetPlat)'=='iOS' AND '$(Platform)'=='ARM64'">arm64</TargetArch>

		<MacBuild>0</MacBuild>
		<MacBuild Condition="$(ProjectName.EndsWith('.Mac'))">1</MacBuild>

		<!-- We mostly treat Mac builds as iOS builds. For scenarios we don't, _TargetPlatInclMac. -->
		<_TargetPlatInclMac>$(_TargetPlat)</_TargetPlatInclMac>
		<_TargetPlatInclMac Condition="$(MacBuild)==1">Mac</_TargetPlatInclMac>

		<DbgBuild>0</DbgBuild>
		<RelBuild>0</RelBuild>
		<EditorBuild>0</EditorBuild>
		<RuntimeBuild>0</RuntimeBuild>
		<UniBuild>0</UniBuild>

		<DbgBuild Condition="$(Configuration.StartsWith('Debug'))">1</DbgBuild>
		<RelBuild Condition="$(DbgBuild)==0">1</RelBuild>
		<!-- Editor build only possible on Windows.
			 It's an editor build if Edittime or Debug build, on Windows. -->
		<EditorBuild Condition="$(_TargetPlat)=='Windows' AND ($(DbgBuild)==1 OR $(Configuration.StartsWith('Edittime')))">1</EditorBuild>
		<RuntimeBuild Condition="$(Configuration.StartsWith('Runtime')) OR $(_TargetPlat)!='Windows'">1</RuntimeBuild>
		<UniBuild Condition="$(Configuration.EndsWith('Unicode'))">1</UniBuild>

		<!-- Unicode path feature -->
		<UnicodeOrBlank></UnicodeOrBlank>
		<UnicodeOrBlank Condition="$(UniBuild)==1">\Unicode</UnicodeOrBlank>

		<!-- Default to 0, no device -->
		<iOSSimulatorBuild Condition="$(iOSSimulatorBuild)!=1">0</iOSSimulatorBuild>
		<!-- i386 and x86_64 are simulator-only targets, so set iOSSimulatorBuild to 1 for the initial run through.
			 Simulator-and-device-in-one targets are handled by first run through
			 building as device, then later a second run as simulator - the switch is
			 handled below, so we don't override here. -->
		<iOSSimulatorBuild Condition="$(_TargetPlatInclMac)=='iOS' AND ('$(TargetArch)'=='i386' OR '$(TargetArch)'=='x86_64')">1</iOSSimulatorBuild>

		<SimulatorOrDevice></SimulatorOrDevice>
		<SimulatorOrDevice Condition="$(_TargetPlatInclMac)=='iOS'">\device</SimulatorOrDevice>
		<SimulatorOrDevice Condition="$(iOSSimulatorBuild)==1">\simulator</SimulatorOrDevice>

		<!-- Not really needed for DarkEdif, it puts all languages in one MFX. -->
		<LangSuffix Condition="$(Configuration.Contains('French'))">_FR</LangSuffix>
		<LangSuffix Condition="$(Configuration.Contains('Japanese'))">_JP</LangSuffix>

		<!-- Roundtrip date/time format, can be parsed back -->
		<BuildDate>$([System.DateTime]::Now.ToString('o'))</BuildDate>
		<!-- Just the year, used in copyright output -->
		<Year>$([System.DateTime]::Now.Year)</Year>

		<!-- For ..\Inc and ..\Lib; OpenCV is in two levels of subfolders. -->
		<SDKRootFolder>..</SDKRootFolder>
		<SDKRootFolder Condition="$(ProjectDir.Contains('OpenCV'))">..\..\..</SDKRootFolder>
		<!--<SDKRootFolder>$([System.IO.Path]::GetFullPath('$(SDKRootFolder)'))</SDKRootFolder>-->

		<SDKType Condition="exists('$(ProjectDir)\DarkExt.json')">DarkEdif</SDKType>
		<SDKType Condition="$(SDKType)=='' AND exists('$(ProjectDir)\Ext.json')">Edif</SDKType>
		<SDKType Condition="$(SDKType)=='' AND exists('$(ProjectDir)\$(SDKRootFolder)\Inc\MagicRData.h')">RSDK</SDKType>
		<SDKType Condition="$(SDKType)==''">MMF2SDK</SDKType>

		<MakePDB>0</MakePDB>
		<MakePDB Condition="$(DbgBuild)==1 OR $(ProjectDir.Contains('DebugObject'))">1</MakePDB>

		<!-- For use to make sure the user set up their template metadata properly. -->
		<IsTemplate Condition="$(ProjectDir.ToLower().Contains('\$(SDKType.ToLower()) template\'))">1</IsTemplate>

		<!-- Write intermediate and output files to an easily deleted/git-ignored folder. -->
		<_FusionSDKTempDir>$(SolutionDir)Temp\$(ExtName)\$(_TargetPlatInclMac)\$(Configuration)$(SimulatorOrDevice)\$(TargetArch)</_FusionSDKTempDir>

		<!-- If user has enabled DarkEdif FusionDebugger class inside their Extension.
			 Note, this also is defined in Android builds and so forth, to allow no-op FusionDebugger functions. -->
		<DarkEdif_FusionDebugger>0</DarkEdif_FusionDebugger>
		<!-- If user has enabled DarkEdif Update Checker inside their Extension. -->
		<DarkEdif_UpdateChecker>0</DarkEdif_UpdateChecker>
		<!-- If user has enabled update checker tagging -->
		<DarkEdif_UCTagging>0</DarkEdif_UCTagging>
	</PropertyGroup>
	<!-- Fusion SDK settings. Sets user preferences. -->
	<PropertyGroup>
		<_FusionSDKConfig Condition="exists('$(ProjectDir)\..\..\FusionSDKConfig.ini')">$([System.IO.File]::ReadAllText('$(ProjectDir)\..\..\FusionSDKConfig.ini'))</_FusionSDKConfig>

		<!-- These are Fusion SDK settings that are needed by the build process, not post-build. -->

		<!-- MakePDBDuringReleaseBuild = true
			 If set to true, will generate _Full and stripped PDB during Edittime and Runtime compilations.
			 Starting "(?im)" sets regex matching to case-insensitive, multiline. -->
		<_MakePDBRegex><![CDATA[(?im)^MakePDBDuringReleaseBuild\s*=\s*true\s*?$]]></_MakePDBRegex>
		<MakePDB Condition="$(MakePDB)==0 AND
			$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_MakePDBRegex)).Success)">1</MakePDB>

		<!-- WindowsXPCompatibility = true|false
			 If set to true, uses Windows XP compatibility if available. -->
		<_WindowsXPCompatibilityRegex><![CDATA[(?im)^WindowsXPCompatibility\s*=\s*false\s*?$]]></_WindowsXPCompatibilityRegex>
		<WindowsXPCompatibility>0</WindowsXPCompatibility>
		<!-- Yep, XP compatible pack is installed. If VS accidentally picks VS 2019 compiler, VCTargets will point to "..\v160\", so
			 we hop up a folder and pick VS 2017 (v150) directly, as the XP compatible pack is VS 2017-based. -->
		<WindowsXPCompatibility Condition="Exists('$(VCTargetsPath)\..\v150\Platforms\Win32\PlatformToolsets\v141_xp\Toolset.props') OR Exists('$(VCTargetsPath)\Platforms\Win32\PlatformToolsets\v141_xp\Toolset.props')">1</WindowsXPCompatibility>
		<WindowsXPCompatibility Condition="$(WindowsXPCompatibility)==1 AND
			$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_WindowsXPCompatibilityRegex)).Success)">0</WindowsXPCompatibility>

		<!-- Windows XP only works properly in VS 2019 16.7 and below (toolset v14.27.29114 and below).
			 Some STL libraries will randomly break otherwise, like std::shared_timed_mutex,
			 because the SDK's lib files under the hood use Vista+ functions, ignoring the compatibility.
			 (in std::shared_timed_mutex's case, it uses Vista-only SRWLock functions). -->
		<VCToolsVersion Condition="$(VCToolsVersion)=='' AND $(WindowsXPCompatibility)==1 AND $(_TargetPlat)=='Windows' AND $(VisualStudioVersion)==16.0">14.27.29110</VCToolsVersion>
		<VCToolsRedistVersion Condition="$(VCToolsRedistVersion)=='' AND $(WindowsXPCompatibility)==1 AND $(_TargetPlat)=='Windows' AND $(VisualStudioVersion)==16.0">14.27.29110</VCToolsRedistVersion>

		<!-- RunStaticCodeAnalysis = true|debugonly
			 If set to true, will cause all settings to be adjusted to run static analysis; including
			 dropping Windows XP compiler, setting MFX output to DLL, etc. Not to be used for releases,
			 but as an in-between to scan your code.
			 DebugOnly will instead only run analysis on Debug/Debug Unicode builds. -->
		<_RunAnalyzerRegex><![CDATA[(?im)^RunStaticCodeAnalysis\s*=\s*([a-z]+)\s*?$]]></_RunAnalyzerRegex>
		<RunAnalyzerSetting Condition="$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_RunAnalyzerRegex)).Success)"
			>$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_RunAnalyzerRegex)).Result('$1'))</RunAnalyzerSetting>

		<!-- RunCodeAnalysis is the property MSVC will read. -->
		<RunCodeAnalysis Condition="$(RunAnalyzerSetting)=='true' OR ($(RunAnalyzerSetting)=='debugonly' AND $(DbgBuild)==1)">true</RunCodeAnalysis>

		<!-- Static analysis won't run on the XP-compatible toolset. -->
		<WindowsXPCompatibility Condition="$(RunCodeAnalysis)=='true'">0</WindowsXPCompatibility>

		<!-- UseLinkTimeCodeGeneration = true|false
			 Will enable Whole Program Optimisation/Link Time Code Generation on the destination projects.
			 This will further optimise the code's speed, possibly making it larger, or smaller.
			 Most effective when multiple libraries are in use by your extension. -->
		<_UseLinkTimeCodeGenerationRegex><![CDATA[(?im)^UseLinkTimeCodeGeneration\s*=\s*true\s*?$]]></_UseLinkTimeCodeGenerationRegex>
		<UseLinkTimeCodeGeneration>0</UseLinkTimeCodeGeneration>
		<UseLinkTimeCodeGeneration Condition="$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_UseLinkTimeCodeGenerationRegex)).Success)">1</UseLinkTimeCodeGeneration>

		<!-- FavorSpeedOrSize = speed|size|size_redist
			 size_redist is like size, but adds a VS Redistributable dependency. -->
		<_FavorSizeOrSpeedRegex><![CDATA[(?im)^FavorSizeOrSpeed\s*=\s*((?:speed)|(?:size(?:_redist)?))\s*?$]]></_FavorSizeOrSpeedRegex>
		<FavorSizeOrSpeed>speed</FavorSizeOrSpeed>
		<FavorSizeOrSpeed Condition="$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_FavorSizeOrSpeedRegex)).Success)"
			>$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_FavorSizeOrSpeedRegex)).Result('$1'))</FavorSizeOrSpeed>

		<!-- EchoAllDefinesFromPropsFileDuringBuild = true
			 If set to true, will write all /D preprocessor to output window when you compile.
			 Used for debugging FusionSDK.props only. -->
		<_EchoAllDefinesFromPropsFileDuringBuildRegex><![CDATA[(?im)^EchoAllDefinesFromPropsFileDuringBuild\s*=\s*true\s*?$]]></_EchoAllDefinesFromPropsFileDuringBuildRegex>
		<EchoAllDefinesFromPropsFileDuringBuild Condition=
			"$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_EchoAllDefinesFromPropsFileDuringBuildRegex)).Success)">1</EchoAllDefinesFromPropsFileDuringBuild>

		<!-- UseMultiProcessorCompilationInDebug = true
			 If set to true, will use multi-processor compilation, disabling incremental rebuild,
			 editing while debugging, etc. See config file.
			 Using multiple processors is enabled by default in non-Debug builds. -->
		<_UseMultiProcessorRegex><![CDATA[(?im)^UseMultiProcessorCompilationInDebug\s*=\s*true\s*?$]]></_UseMultiProcessorRegex>
		<_UseMultiProcessor Condition=
			"$(RelBuild)==1 OR $([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_UseMultiProcessorRegex)).Success)">1</_UseMultiProcessor>

		<!-- iPhone extensions are packaged into zips, with extensions EXT, or for Mac, DAT -->
		<ZipExt>ZIP</ZipExt>
		<ZipExt Condition="'$(_TargetPlatInclMac)'=='iOS'">EXT</ZipExt>
		<ZipExt Condition="'$(_TargetPlatInclMac)'=='Mac'">DAT</ZipExt>
	</PropertyGroup>
	<PropertyGroup Condition="$(SDKType.Contains('Edif'))" Label="UserMacros">
		<_JSON Condition="$(SDKType)=='DarkEdif'">$([System.IO.File]::ReadAllText('$(ProjectDir)\DarkExt.json'))</_JSON>
		<_JSON Condition="$(SDKType)=='Edif'">$([System.IO.File]::ReadAllText('$(ProjectDir)\Ext.json'))</_JSON>

		<!-- Find the line where Extension::Version is defined, read number -->
		<_ExtVersionRegex><![CDATA[Version\s*=\s*(\d*);]]></_ExtVersionRegex>
		<ExtVersion Condition="!$(ProjectDir.Contains('Bluewing'))">$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(ProjectDir)Extension.hpp')), $(_ExtVersionRegex)).Result('$1'))</ExtVersion>

		<_ExtVersionRegex><![CDATA[relayclient[^}]*?buildnum\s*=\s*(\d*);]]></_ExtVersionRegex>
		<ExtVersion Condition="$(ProjectDir.Contains('Bluewing Client'))">$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(ProjectDir)\$(SDKRootFolder)\Lib\Shared\Lacewing\Lacewing.h')), $(_ExtVersionRegex)).Result('$1'))</ExtVersion>
		<_ExtVersionRegex><![CDATA[relayserver[^}]*?buildnum\s*=\s*(\d*);]]></_ExtVersionRegex>
		<ExtVersion Condition="$(ProjectDir.Contains('Bluewing Server'))">$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(ProjectDir)\$(SDKRootFolder)\Lib\Shared\Lacewing\Lacewing.h')), $(_ExtVersionRegex)).Result('$1'))</ExtVersion>

		<!-- Find the first Author line in JSON, read its value.
			 Starting "(?im)" sets regex matching to case-insensitive, multiline. -->
		<_AuthorNameRegex><![CDATA[(?im)"Author"\s*:\s*"(.*)"\s*?,\s*$]]></_AuthorNameRegex>
		<AuthorName>$([System.Text.RegularExpressions.Regex]::Match($(_JSON), $(_AuthorNameRegex)).Result('$1'))</AuthorName>

		<!-- Use Author Name if company isn't found -->
		<_CompanyNameRegex><![CDATA[(?im)"Company"\s*:\s*"(.*)"\s*?,\s*$]]></_CompanyNameRegex>
		<_ExtH Condition="$(SDKType)=='DarkEdif'">$([System.IO.File]::ReadAllText('$(ProjectDir)\Extension.hpp'))</_ExtH>
		<_ExtH Condition="$(SDKType)=='Edif'">$([System.IO.File]::ReadAllText('$(ProjectDir)\Extension.h'))</_ExtH>
		<CompanyName Condition="$(_JSON.Contains('CompanyName'))">$([System.Text.RegularExpressions.Regex]::Match($(_ExtH), $(_CompanyNameRegex)).Result('$1').Replace('\'', '\u0027'))</CompanyName>
		<CompanyName Condition="$(CompanyName)==''">$(AuthorName)</CompanyName>

		<!-- This define is true if FusionDebugger variable is detected in Extension.hpp, it's true at runtime. -->
		<_DarkEdif_DetectFusionDebuggerRegex><![CDATA[(?m)^\s*DarkEdif::FusionDebugger\s+FusionDebugger\s*;\s*$]]></_DarkEdif_DetectFusionDebuggerRegex>
		<DarkEdif_FusionDebugger Condition="$(SDKType)=='DarkEdif' AND $([System.Text.RegularExpressions.Regex]::IsMatch($(_ExtH), $(_DarkEdif_DetectFusionDebuggerRegex)))">1</DarkEdif_FusionDebugger>

		<!-- This define is true if SDKUpdater::RunUpdateNotifs() function is detected in Edittime.cpp -->
		<_DarkEdif_DetectUpdateCheckerRegex><![CDATA[(?m)^\s*DarkEdif::SDKUpdater::RunUpdateNotifs\s*\(]]></_DarkEdif_DetectUpdateCheckerRegex>
		<DarkEdif_UpdateChecker Condition="$(SDKType)=='DarkEdif' AND $(EditorBuild)==1 AND $([System.Text.RegularExpressions.Regex]::IsMatch($([System.IO.File]::ReadAllText('$(ProjectDir)\Edittime.cpp')), $(_DarkEdif_DetectUpdateCheckerRegex)))">1</DarkEdif_UpdateChecker>

		<!-- This define is true if you want to analyse your code for more subtly incorrect code, which doesn't cause compiler/linker errors-->
		<_RunAnalyzerRegex><![CDATA[(?im)^RunStaticCodeAnalysis\s*=\s*([a-z]+)\s*?$]]></_RunAnalyzerRegex>
		<RunAnalyzerSetting Condition="$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_RunAnalyzerRegex)).Success)"
			></RunAnalyzerSetting>

		<!-- This define is true if you want to machine-uniquely tag your extensions -->
		<_DarkEdif_UCTaggingRegex><![CDATA[(?im)^DarkEdifUpdateCheckerTagging\s*=\s*(.*?)\s*?$]]></_DarkEdif_UCTaggingRegex>
		<DarkEdif_UCTaggingINI Condition="$(SDKType)=='DarkEdif' AND $(EditorBuild)==1 AND $([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_DarkEdif_UCTaggingRegex)).Success)">$([System.Text.RegularExpressions.Regex]::Match($(_FusionSDKConfig), $(_DarkEdif_UCTaggingRegex)).Result('$1'))</DarkEdif_UCTaggingINI>
		<DarkEdif_UCTagging Condition="$(DarkEdif_UCTaggingINI.Contains('$(ExtName)'))">1</DarkEdif_UCTagging>
	</PropertyGroup>
	<PropertyGroup Condition="$(SDKType.Contains('MMF2SDK'))" Label="UserMacros">
		<ExtVersion>1</ExtVersion>

		<_RCFile>$([System.IO.File]::ReadAllText('$(ProjectDir)\Ext.rc'))</_RCFile>

		<!-- Find the first Author line in RC file, read its value.
			 Starting "(?im)" sets regex matching to case-insensitive, multiline.
			 There is a final Replace to make ' turn into its arbitrary Unicode value,
			 so the preprocessor doesn't get puzzled while stringifying it. -->
		<_AuthorNameRegex><![CDATA[(?im)IDST_AUTHOR[ \t]+"([^\n]+)"\s*?$]]></_AuthorNameRegex>
		<AuthorName>$([System.Text.RegularExpressions.Regex]::Match($(_RCFile), $(_AuthorNameRegex)).Result('$1'))</AuthorName>

		<!-- Use Author Name if company isn't found -->
		<CompanyName>$(AuthorName)</CompanyName>

		<!-- Exception for MMF2SDK_Unicode, whose template is Simple Control.
			 Might change that later. -->
		<IsTemplate Condition="$(ProjectDir.ToLower().Contains('\mmf2sdk_unicode\simple control\'))">1</IsTemplate>
	</PropertyGroup>
	<PropertyGroup Condition="$(SDKType)=='RSDK'" Label="UserMacros">
		<ExtVersion>1</ExtVersion>

		<_InfoFile>$([System.IO.File]::ReadAllText('$(ProjectDir)\Information.h'))</_InfoFile>

		<_AuthorNameRegex><![CDATA[(?im)#define[ \t]+ObjectAuthor[ \t]+"([^\n]+)"\s*?$]]></_AuthorNameRegex>
		<AuthorName>$([System.Text.RegularExpressions.Regex]::Match($(_InfoFile), $(_AuthorNameRegex)).Result('$1'))</AuthorName>
		<CompanyName>$(AuthorName)</CompanyName>
	</PropertyGroup>
	<PropertyGroup Label="UserMacros" Condition="$(_TargetPlat)=='Windows'">
		<!-- Broken in latest MS
		<_FusionSDKAdds>/D "CONFIG=$(Configuration)" /D "PROJECT_NAME=\"$(ExtName)\""
			/D "AUTHOR_NAME=\"$(AuthorName)\"" /D "COMPANY_NAME=\"$(CompanyName)\""
			/D "EXTENSION_VERSION=$(ExtVersion)"
			/D "BUILD_DATE=\"$(BuildDate)\"" /D "YEAR=\"$(Year)\""
			/D "USE_DARKEDIF_UPDATE_CHECKER=$(DarkEdif_UpdateChecker)"
			/D "USE_DARKEDIF_FUSION_DEBUGGER=$(DarkEdif_FusionDebugger)"</_FusionSDKAdds> -->
		<!-- Do not include build date in the C++ compilation. It causes VS to think the whole
			 project needs rebuilding on every run. -->
		<_FusionSDKAdds>/D "CONFIG=$(Configuration)" /D "PROJECT_NAME=STRIFY($(ExtName))"
			/D "AUTHOR_NAME=STRIFY($(AuthorName))" /D "COMPANY_NAME=STRIFY($(CompanyName))"
			/D "EXTENSION_VERSION=$(ExtVersion)" /D "YEAR=STRIFY($(Year))"
			/D "USE_DARKEDIF_UPDATE_CHECKER=$(DarkEdif_UpdateChecker)"
			/D "USE_DARKEDIF_FUSION_DEBUGGER=$(DarkEdif_FusionDebugger)"
			/D "EditorBuild=$(EditorBuild)" /D "RuntimeBuild=$(RuntimeBuild)" /D "UniBuild=$(UniBuild)"
			/D "USE_DARKEDIF_UC_TAGGING=$(DarkEdif_UCTagging)" /D "MacBuild=$(MacBuild)"
			</_FusionSDKAdds>
		<!-- ResourceCompiler doesn't like newlines. -->
		<_FusionSDKAdds>$(_FusionSDKAdds.Replace('\n',' ').Replace('\t',' '))</_FusionSDKAdds>
		<!-- #if EditorBuild needs to evaluate to true.
			 Worth noting in ResourceCompiler, "true" is not true. 1 is apparently true though. -->
		<_FusionSDKAddsRC>$(_FusionSDKAdds.Replace('\n',' ').Replace('\','\\\').Replace('STRIFY(','asStr(')) /D "BUILD_DATE=asStr($(BuildDate))"</_FusionSDKAddsRC>
	</PropertyGroup>
	<PropertyGroup Condition="$(_TargetPlat)=='Android' OR $(_TargetPlat)=='iOS'">
		<!-- Android uses Clang, a different format of commandline items
			-D PROJECT_NAME=\"$(ExtName)\"
			-D AUTHOR_NAME=\"$(AuthorName)\" -D "COMPANY_NAME=\"$(CompanyName)\"
			-D EXTENSION_VERSION=$(ExtVersion)
			-D BUILD_DATE=\"$(BuildDate)\" -D YEAR=\"$(Year)\"		-->
		<!-- Doesn't work due to MS bug.
		<_FusionSDKAdds>CONFIG=$(Configuration);PROJECT_NAME="$(ExtName)";AUTHOR_NAME="$(AuthorName)";COMPANY_NAME="$(CompanyName)";EXTENSION_VERSION=$(ExtVersion);YEAR="$(Year)"</_FusionSDKAdds> -->
		<_FusionSDKAdds>CONFIG=$(Configuration);PROJECT_NAME=STRIFY($(ExtName));PROJECT_NAME_UNDERSCORES=STRIFY($(ExtName.Replace(' ','_')));AUTHOR_NAME=STRIFY($(AuthorName));COMPANY_NAME=STRIFY($(CompanyName));EXTENSION_VERSION=$(ExtVersion);YEAR=STRIFY($(Year));USE_DARKEDIF_FUSION_DEBUGGER=$(DarkEdif_FusionDebugger);EditorBuild=$(EditorBuild);RuntimeBuild=$(RuntimeBuild);UniBuild=$(UniBuild);MacBuild=$(MacBuild)</_FusionSDKAdds>

		<!-- Not defined by Clang, just MSVC. -->
		<_FusionSDKAdds Condition="$(DbgBuild)==1">$(_FusionSDKAdds);_DEBUG=1</_FusionSDKAdds>
	</PropertyGroup>
	<Choose>
		<When Condition="$(_TargetPlat)=='Windows'">
			<PropertyGroup Label="UserMacros">
				<MFXDir Condition="$(EditorBuild)==1">$(SolutionDir)MFX\Extensions$(UnicodeOrBlank)</MFXDir>
				<MFXDir Condition="$(RuntimeBuild)==1">$(SolutionDir)MFX\Data\Runtime$(UnicodeOrBlank)</MFXDir>
				<MFXDir Condition="$(Configuration.StartsWith('Vitalize'))">$(SolutionDir)MOX</MFXDir>
			</PropertyGroup>
		</When>
		<When Condition="$(_TargetPlat)=='Android'">
			<PropertyGroup Label="UserMacros">
				<MFXDir>$(SolutionDir)MFX\Data\Runtime\Android</MFXDir>
			</PropertyGroup>
		</When>
		<When Condition="$(_TargetPlatInclMac)=='iOS'">
			<PropertyGroup Label="UserMacros">
				<MFXDir>$(SolutionDir)MFX\Data\Runtime\iPhone</MFXDir>
			</PropertyGroup>
		</When>
		<When Condition="$(_TargetPlatInclMac)=='Mac'">
			<PropertyGroup Label="UserMacros">
				<MFXDir>$(SolutionDir)MFX\Data\Runtime\Mac</MFXDir>
			</PropertyGroup>
		</When>
	</Choose>
	<!-- All runtimes should have these -->
	<PropertyGroup Label="Configuration">
		<!-- Only used in CLR (C# mixed with C++) -->
		<RootNamespace>$(SDKType)</RootNamespace>
		<!-- MFX files are internally DLLs, apart from on iOS/Mac -->
		<ConfigurationType Condition="$(_TargetPlat)!='iOS'">DynamicLibrary</ConfigurationType>

		<!-- TargetName is incorrect on Android/iOS, due to project name containing '.' -->
		<TargetName>$(ExtName)$(LangSuffix)</TargetName>
		<TargetName Condition="$(_TargetPlat)=='Android' OR $(_TargetPlatInclMac)=='iOS'">lib$(ExtName.Replace(' ','_'))$(LangSuffix)</TargetName>

		<ExtNameUnderscores>$(ExtName.Replace(' ','_'))</ExtNameUnderscores>

		<!-- Prevent the madness of every linked DLL being copied to output folder. -->
		<CopyCppRuntimeToOutputDir>false</CopyCppRuntimeToOutputDir>

		<!-- Unfortunately, VS pushes all its runtime DLLs here, even in static library build.
			 May be a bug, but until it's fixed, we're gonna use the override of tags for MFX
			 and PDB below: namely, tags OutputFile, ProgramDatabaseFile, and StripPrivateSymbols. -->
		<OutDir>$(_FusionSDKTempDir)\</OutDir>
		<!-- Write all intermediate files here. -->
		<IntDir>$(_FusionSDKTempDir)\</IntDir>

		<!-- Minifies JSON file and builds call table for runtimes that lack A/C/E ASM -->
		<DarkEdifPreBuildToolParams>/ProjName="$(ExtName)" /TargetPlat="$(_TargetPlatInclMac)" /TargetArch="$(TargetArch)" /MacroInputFile="$(SDKRootFolder)\Lib\Shared\ACECallTable_Macro.cpp"  /MacroOutputFile="$(SolutionDir)\Temp\$(ExtName)\Temp_ACECallTable.cpp" /JSONInputPathToMinify="$(ProjectDir)\DarkExt.json" /FusionConfigIniPath="$(SolutionDir)FusionSDKConfig.ini"</DarkEdifPreBuildToolParams>
	</PropertyGroup>
	<!-- Worth noting a When cannot contain a ItemDefinitionGroup -->
	<ItemDefinitionGroup Label="Configuration">
		<ClCompile>
			<!-- All configs, all platforms -->
			<!-- COXSDK is the general SDK term for all Fusion SDKs.
				 HWABETA is access to HWA stuff. It's been HWABETA since introduction.
				 Worth noting base SDK defines _WINDOWS, and rSDK additionally defines RSDK. -->
			<!-- Due to access to C stuff, there's plenty of complaints about risky behaviour -->
			<PreprocessorDefinitions>COXSDK;HWABETA;_CRT_SECURE_NO_WARNINGS;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>

			<!-- Indicates this is the SDK template. -->
			<PreprocessorDefinitions Condition="$(IsTemplate)==1">IS_$(SDKType.ToUpper())_TEMPLATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>

			<!-- Debug or Edittime configs have EDITOR #defined -->
			<PreprocessorDefinitions Condition="$(EditorBuild)==1">EDITOR;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<!-- Runtime configs have RUN_ONLY #defined -->
			<PreprocessorDefinitions Condition="$(RuntimeBuild)==1">RUN_ONLY;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<!-- non-Debug needs NDEBUG -->
			<PreprocessorDefinitions Condition="$(RelBuild)==1">NDEBUG;$(PreprocessorDefinitions)%(PreprocessorDefinitions)</PreprocessorDefinitions>

			<PreprocessorDefinitions Condition="$(_TargetPlat)=='Android' OR '$(_TargetPlat)'=='iOS'">$(_FusionSDKAdds);%(PreprocessorDefinitions);</PreprocessorDefinitions>

			<!-- Not including ProjectDir causes includes of "Common.hpp" from the DarkEdif SDK to fail.
				 OpenCV's projects are in an addition layer of subfolders. -->
			<AdditionalIncludeDirectories>$(ProjectDir.TrimEnd('\'));$(SDKRootFolder)\Inc\$(_TargetPlatInclMac);$(SDKRootFolder)\Inc\Shared;$(SolutionDir)Temp\$(ExtName);$(SDKRootFolder)\Inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
		</ClCompile>
		<Link>
			<AdditionalLibraryDirectories>$(ProjectDir.TrimEnd('\'));$(SDKRootFolder)\Lib\$(_TargetPlat)\$(TargetArch);$(SDKRootFolder)\Lib\$(_TargetPlat);$(SDKRootFolder)\Lib\Shared;$(SolutionDir)Temp\$(ExtName);$(SDKRootFolder)\Lib;%(AdditionalLibraryDirectories);</AdditionalLibraryDirectories>
		</Link>
	</ItemDefinitionGroup>


<!--#################################
		BEGIN Windows
	################################# -->
	<!-- Wish I could merge all these into a Choose,
		 but ItemDefinitionGroup can't be in a Choose. -->

	<PropertyGroup Label="Configuration" Condition="'$(_TargetPlat)'=='Windows'">
		<!-- Latest XP-compatible compiler.
			 While pre-XP may still run on XP compiler, it's dubious.
			 In a similar vein, the XP compiler may work on pre-XP, but also dubious. -->
		<PlatformToolset Condition="$(WindowsXPCompatibility)==1">v141_xp</PlatformToolset>
		<!-- Prevent Windows XP not-being-supported-later warnings -->
		<XPDeprecationWarning Condition="$(WindowsXPCompatibility)==1">false</XPDeprecationWarning>
		<MSBuildWarningsAsMessages Condition="$(WindowsXPCompatibility)==1">MSB8012;$(MSBuildWarningsAsMessages)</MSBuildWarningsAsMessages>

		<!-- If not XP, then use the latest compiler. $(PlatformToolsetVersion) is not available,
			 so the following "check for toolset" are copied from Microsoft.Cpp.Defaults.props;
			 v141 = VS 2017, v142 = VS 2019, v143 = VS 2022. Note v100 (VS 2010) is MS's default. -->
		<PlatformToolset Condition="$(PlatformToolset)==''">v100</PlatformToolset>
		<PlatformToolset Condition="$(PlatformToolset)=='v100' AND
			Exists('$(VCTargetsPath)Platforms\Win32\PlatformToolsets\v143\Toolset.props')">v143</PlatformToolset>
		<PlatformToolset Condition="$(PlatformToolset)=='v100' AND
			Exists('$(VCTargetsPath)\Platforms\Win32\PlatformToolsets\v142\Toolset.props')">v142</PlatformToolset>
		<PlatformToolset Condition="$(PlatformToolset)=='v100' AND
			Exists('$(VCTargetsPath)\Platforms\Win32\PlatformToolsets\v141\Toolset.props')">v141</PlatformToolset>

		<!-- MFX is reverted to DLL by MS's second VS property sheet, necessitating a AfterVSDefs props file. -->
		<TargetExt Condition="$(RunCodeAnalysis)!='true'">.mfx</TargetExt>
		<TargetExt Condition="$(RunCodeAnalysis)=='true'">.dll</TargetExt>

		<!-- UAC priviledges are based on app, not the DLLs that are Fusion MFX files. -->
		<GenerateManifest>false</GenerateManifest>

		<!-- Causes auto-defines of _UNICODE and so forth -->
		<CharacterSet Condition="$(UniBuild)==0">NotSet</CharacterSet>
		<CharacterSet Condition="$(UniBuild)==1">Unicode</CharacterSet>

		<!-- Instead of putting in output folder, put it here. -->
		<CodeAnalysisLogFile>$(IntDir)$(TargetFileName).CodeAnalysisLog.xml</CodeAnalysisLogFile>
		<CodeAnalysisSucceededFile>$(IntDir)$(TargetFileName).lastcodeanalysissucceeded</CodeAnalysisSucceededFile>
	</PropertyGroup>
	<ItemDefinitionGroup Label="Configuration" Condition="$(_TargetPlat)=='Windows'">
		<ClCompile>
			<!-- UTF-8 everywhere! -->
			<UseUnicodeForAssemblerListing>true</UseUnicodeForAssemblerListing>

			<!-- Old SDKs need this defined. -->
			<PreprocessorDefinitions Condition="$(SDKType)!='DarkEdif'">_WINDOWS;IN_EXT_VERSION2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<!-- Windows XP SP2+ targeting needs manual defines to adjust what WinAPI functions are hidden or declared.
				 For XP, it's normally 0x0501. 0x05010300 for XP SP3+.
				 0x0502 is XP SP2+ with Windows Server 2003+.
				 Was in Fusion SDK headers, but external libraries won't respect that without pedantic header ordering. -->
			<PreprocessorDefinitions Condition="$(WindowsXPCompatibility)==1">_WIN32_WINNT=0x0502;WINVER=0x0502;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<!-- Disable the bad-practice min/max preprocessor macros.
				 Also disable Windows.h including extra headers, which can still be included manually.
				 STRICT is also defined. Seems to enable more type safety (e.g. for handles). -->
			<PreprocessorDefinitions>NOMINMAX;WIN32_LEAN_AND_MEAN;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>

			<!-- Max number of warnings without being asinine -->
			<WarningLevel>Level3</WarningLevel>
			<!-- Use C++ 2017 Standard (C++17) -->
			<LanguageStandard>stdcpp17</LanguageStandard>
			<!-- Use all processors during compilation. Not noticeable during multi-project building,
				 but matters when it's one project. -->
			<MultiProcessorCompilation Condition="$(_UseMultiProcessor)==1">true</MultiProcessorCompilation>

			<!-- Define PROJECT_NAME for use in DLL metadata. Unfortunately, we don't know company name.
				 Can't do it in PreprocessorDefinitions, it doesn't like projects with spaces in their
				 name.
				 Also, make __cplusplus represent the C++ standard for MSVC. -->
			<AdditionalOptions>$(_FusionSDKAdds) /Zc:__cplusplus %(AdditionalOptions)</AdditionalOptions>
			<!-- Disable thread-safe initialization on XP, as VS 2019 uses Vista+ functionality to implement it.
				 This will only create a problem if you have statics accessed from multiple threads that spawn at the same time. To conditionally write code for this, see __cpp_threadsafe_static_init. -->
			<AdditionalOptions Condition="$(WindowsXPCompatibility)==1 AND $(VisualStudioVersion)==16.0">/Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
		</ClCompile>
		<Link>
			<!-- Windows subsystem. Required to prevent a warning message -->
			<SubSystem>Windows</SubSystem>
			<!-- MFX file needs redirecting. -->
			<OutputFile>$(MFXDir)\$(TargetName)$(TargetExt)</OutputFile>

			<!-- Debug symbols: first, the full debug symbols with all code. -->
			<ProgramDatabaseFile Condition="$(MakePDB)==1">$(MFXDir)\$(TargetName)_Full.pdb</ProgramDatabaseFile>
			<!-- Next, stripped debug symbols with just function names/addresses.
				 Good for releasing to developers without releasing code. -->
			<StripPrivateSymbols Condition="$(MakePDB)==1">$(MFXDir)\$(TargetName).pdb</StripPrivateSymbols>

			<!-- Customise the amount of detail in the non-stripped PDB. -->
			<!-- Full debug is for sharing/publishing -->
			<GenerateDebugInformation Condition="$(MakePDB)==1 AND $(DbgBuild)==0">DebugFull</GenerateDebugInformation>
			<!-- This one is bulkier, but faster to make and better for local debug -->
			<GenerateDebugInformation Condition="$(MakePDB)==1 AND $(DbgBuild)==1">true</GenerateDebugInformation>

			<!-- If debug build, add profiling information -->
			<Profile Condition="$(DbgBuild)==1">true</Profile>

			<!-- Support up to 4GB RAM addresses, not 2GB -->
			<LargeAddressAware>true</LargeAddressAware>

			<!-- Add the Fusion library.
				 The one that's 325kb comes with CF2.5 SDK, but works in Fusion 2.0 through 2.5
				 Includes HWA features, plus both ANSI and Unicode functions.
				 Worth noting wchar_t it uses is type unsigned short, not __wchar_t.
				 VS allows use of ushort via /Zc:wchar_t, but it causes failure to link with
				 correct wchar_t linking libraries. -->
			<AdditionalDependencies Condition="$(SDKType)=='DarkEdif'">$(SDKRootFolder)\Lib\Windows\mmfs2.lib;%(AdditionalDependencies)</AdditionalDependencies>
			<AdditionalDependencies Condition="$(SDKType)!='DarkEdif'">$(SDKRootFolder)\Lib\mmfs2.lib;%(AdditionalDependencies)</AdditionalDependencies>

			<!-- This moves the generated .lib and .exp outside the MFX folder. We don't need these
				 files at all, but .exp can't be turned off. -->
			<ImportLibrary>$(IntDir)$(TargetName).lib</ImportLibrary>

			<!-- We can turn off the .lib though. -->
			<AdditionalOptions>/NOIMPLIB %(AdditionalOptions)</AdditionalOptions>

			<!-- DarkEdif uses #pragma DllExportHint in functions to expose them externally.
				 All other SDKs rely on both DllExport annotation and Ext.def uncommenting. -->
			<ModuleDefinitionFile Condition="$(SDKType)!='DarkEdif'">Ext.def</ModuleDefinitionFile>
		</Link>
		<ResourceCompile>
			<!-- Important. Used to be defined by CCX.h -->
			<PreprocessorDefinitions>KPX_MAGICNUMBER=200;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<!-- Debug or Edittime configs have EDITOR #defined -->
			<PreprocessorDefinitions Condition="$(EditorBuild)==1">EDITOR;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<!-- Runtime configs have RUN_ONLY #defined -->
			<PreprocessorDefinitions Condition="$(RuntimeBuild)==1">RUN_ONLY;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<!-- Edittime or Runtime needs NDEBUG -->
			<PreprocessorDefinitions Condition="$(RelBuild)==1">NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<!-- Define PROJECT_NAME for use in DLL metadata. Unfortunately, we don't know company name.
				 Can't do it in PreprocessorDefinitions, it doesn't like projects with spaces in their
				 name. -->
			<AdditionalOptions>$(_FusionSDKAddsRC) %(AdditionalOptions)</AdditionalOptions>

			<!-- Allow #include to pull, first from platform-specific Inc, then Shared Inc -->
			<AdditionalIncludeDirectories>$(SDKRootFolder)/$(_TargetPlat)/Inc;$(SDKRootFolder)/Shared/Inc;$(SDKRootFolder)/Inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
		</ResourceCompile>
	</ItemDefinitionGroup>

	<!-- Windows: configuration type -->

	<!-- ## Debug, Debug Unicode -->
	<PropertyGroup Label="Configuration" Condition="$(_TargetPlat)=='Windows' AND $(DbgBuild)==1">
		<!-- Enables EditAndContinue, devs can modify functions mid-debug session -->
		<LinkIncremental Condition="$(_UseMultiProcessor)==0">true</LinkIncremental>
	</PropertyGroup>
	<ItemDefinitionGroup Label="Configuration" Condition="$(_TargetPlat)=='Windows' AND $(DbgBuild)==1">
		<ClCompile>
			<!-- Make debugging more accurate -->
			<RuntimeLibrary Condition="$(FavorSizeOrSpeed)!='size_redist'">MultiThreadedDebug</RuntimeLibrary>
			<RuntimeLibrary Condition="$(FavorSizeOrSpeed)=='size_redist'">MultiThreadedDebugDll</RuntimeLibrary>
			<RuntimeTypeInfo>true</RuntimeTypeInfo>
			<Optimization>Disabled</Optimization>
			<!-- Turn on all checks for simple mistakes -->
			<BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
			<!-- This is enabled by debug anyway, but to make it explicit on the property page -->
			<BufferSecurityCheck>true</BufferSecurityCheck>
			<!-- Adds extra checks to prevent running non-function code as if it was a function -->
			<ControlFlowGuard>Guard</ControlFlowGuard>
			<!-- Allow user to edit their code mid-debug, only possible if not multiprocessor -->
			<DebugInformationFormat Condition="$(_UseMultiProcessor)==0">EditAndContinue</DebugInformationFormat>
			<DebugInformationFormat Condition="$(_UseMultiProcessor)==1">ProgramDatabase</DebugInformationFormat>
			<!-- Enable COMDATs, necessary for Edit and Continue debugging -->
			<FunctionLevelLinking>true</FunctionLevelLinking>
		</ClCompile>
		<Link>
			<!-- Required for incremental linking to work. -->
			<AdditionalOptions Condition="$(_UseMultiProcessor)==0">/SAFESEH:NO %(AdditionalOptions)</AdditionalOptions>
		</Link>
	</ItemDefinitionGroup>
	<!-- ## Edittime, Edittime Unicode, Runtime, Runtime Unicode -->
	<PropertyGroup Label="Configuration" Condition="$(_TargetPlat)=='Windows' AND $(DbgBuild)==0">
		<!-- Link Time Code Generation. See the same property under ClCompile. -->
		<WholeProgramOptimization Condition="$(UseLinkTimeCodeGeneration)==1">true</WholeProgramOptimization>
	</PropertyGroup>
	<ItemDefinitionGroup Label="Configuration" Condition="$(_TargetPlat)=='Windows' AND $(DbgBuild)==0">
		<ClCompile>
			<RuntimeLibrary Condition="$(FavorSizeOrSpeed)!='size_redist'">MultiThreaded</RuntimeLibrary>
			<RuntimeLibrary Condition="$(FavorSizeOrSpeed)=='size_redist'">MultiThreadedDll</RuntimeLibrary>

			<!-- Link Time Code Generation; allows a thorough optimisation after compilation,
				 by doing the optimisation process when all compiled files can be inspected. -->
			<WholeProgramOptimization Condition="$(UseLinkTimeCodeGeneration)==1">true</WholeProgramOptimization>
			<!-- LTCG optimisation type -->
			<FavorSizeOrSpeed Condition="$(UseLinkTimeCodeGeneration)==1">$(FavorSizeOrSpeed)</FavorSizeOrSpeed>
			<!-- Replace functions with direct ASM where possible -->
			<IntrinsicFunctions Condition="$(FavorSizeOrSpeed)=='speed'">true</IntrinsicFunctions>
			<!-- Moves all texts in the program to a single section, removing overlaps, to improve size -->
			<StringPooling>true</StringPooling>
			<!-- No checks, we want speed -->
			<BufferSecurityCheck>false</BufferSecurityCheck>
			<!-- Optimise favouring a smaller size over faster speed, if set to -->
			<Optimization Condition="$(FavorSizeOrSpeed.StartsWith('size'))">MinSpace</Optimization>
			<!-- Speed is preferred over size; note VS 2017 (15.x) does not support Ob3. -->
			<AdditionalOptions Condition="$(FavorSizeOrSpeed)=='speed' AND $(PlatformToolset)!='v141' AND $(VisualStudioVersion) &gt;= '16.0'">/Ob3 %(AdditionalOptions)</AdditionalOptions>
			<InlineFunctionExpansion Condition="$(FavorSizeOrSpeed)=='speed' AND $(PlatformToolset)=='v141'">AnySuitable</InlineFunctionExpansion>
			<InlineFunctionExpansion Condition="$(FavorSizeOrSpeed.StartsWith('size'))">OnlyExplicitInline</InlineFunctionExpansion>
		</ClCompile>
		<Link>
			<!-- Removes unused functions, can't be used in debug due to Incremental -->
			<OptimizeReferences>true</OptimizeReferences>
			<!-- Required for Link Time Code Generation to work -->
			<EnableCOMDATFolding Condition="$(UseLinkTimeCodeGeneration)==1">true</EnableCOMDATFolding>
		</Link>
	</ItemDefinitionGroup>

<!--#################################
		END Windows
		BEGIN Android and iOS
	################################# -->
	<PropertyGroup Condition="'$(_TargetPlat)'!='Windows'">
		<!-- To move the compiled SO file into the Data\Runtime\Android/iOS zip file. -->
		<DarkEdifPostBuildToolParams>/ProjName="$(ExtName)" /TargetArch="$(TargetArch)" /InputSOFolder="$(OutDir.TrimEnd('\'))" /OutputDir="$(MFXDir.TrimEnd('\'))" /ProjectDir="$(ProjectDir.TrimEnd('\'))" /TargetPlat="$(_TargetPlatInclMac)" /ProjConfig="$(Configuration)" /FusionConfigIniPath="$(SolutionDir)FusionSDKConfig.ini"</DarkEdifPostBuildToolParams>
	</PropertyGroup>

<!--#################################
		END Android and iOS
		BEGIN Android-only
	################################# -->
	<PropertyGroup Label="Configuration" Condition="'$(_TargetPlat)'=='Android'">
		<!-- Debug libraries on Debug config -->
		<UseDebugLibraries>false</UseDebugLibraries>
		<UseDebugLibraries Condition="$(DbgBuild)==1">true</UseDebugLibraries>
		<!-- Clang 5.0 is latest VS can use, packed with r16b. Clang 9.0 is the most recent. -->
		<PlatformToolset>Clang_5_0</PlatformToolset>
		<!-- Use LLVM Static C++ Runtime library. It's the only one supported by Google,
			 the GNU STL is second-best but doesn't play nice all the time.
			 https://www.phoronix.com/scan.php?page=news_item&px=Android-NDK-r16 -->
		<UseOfStl>c++_static</UseOfStl>

		<!-- Generate ARM style code for Thumb archs. -->
		<ThumbMode Condition="'$(Platform)'=='ARM'">ARM</ThumbMode>
		<!-- API that's readily accessible. Note 21 is minimum 64-bit API. -->
		<AndroidAPILevel>android-19</AndroidAPILevel>
		<AndroidAPILevel Condition="'$(Platform)'=='ARM64' OR '$(Platform)'=='x64'">android-21</AndroidAPILevel>

		<!-- We should use _UseMultiProcessor, but on Windows, that prevents incremental linking.
			 Not so on Android, so we use it all the time. -->
		<UseMultiToolTask>true</UseMultiToolTask>
	</PropertyGroup>
	<ItemDefinitionGroup Label="Configuration" Condition="'$(_TargetPlat)'=='Android'">
		<ClCompile>
			<!-- Use C++17, and C11, latest finalised standards. -->
			<CppLanguageStandard>c++1z</CppLanguageStandard>
			<CLanguageStandard>c11</CLanguageStandard>

			<!-- Make it easier to do a call stack trace; also, smaller files. -->
			<FunctionLevelLinking>true</FunctionLevelLinking>
			<DataLevelLinking>true</DataLevelLinking>

			<!-- Allows debugging in GDB/Visual Studio. -->
			<ExceptionHandling>UnwindTables</ExceptionHandling>
			<DebugInformationFormat>FullDebug</DebugInformationFormat>

			<!-- Don't include debugger info in release builds. -->
			<DebugInformationFormat Condition="$(RelBuild)==1">None</DebugInformationFormat>

			<!-- Not necessary in Release, but has minimal size changes. -->
			<RuntimeTypeInfo>true</RuntimeTypeInfo>

			<!-- Manually add includes -->
			<AdditionalIncludeDirectories>$(Sysroot)\usr\include;$(StlIncludeDirectories);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>

			<!-- Don't export any functions by default, as Java doesn't need to see them.
				 Char is signed in normal builds, but runs as unsigned on built APKs - override that.
				 Disable #pragma comment getting compiler upset, and other issues. -->
			<AdditionalOptions>-fvisibility=hidden -fsigned-char -fPIC -fasm-blocks -Wno-unknown-pragmas -Wno-unused-const-variable -Wno-missing-braces %(AdditionalOptions)</AdditionalOptions>
		</ClCompile>
		<Link>
			<VerboseOutput>false</VerboseOutput>
			<OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>

			<!-- Include math library (libm.so). -->
			<LibraryDependencies>$(StlLibraryName);m;%(LibraryDependencies)</LibraryDependencies>
			<!-- Include android_support library for x86 and ARM (available in x86/ARM constantly, but only in ARM64/x64 for NDK17 and lower) -->
			<LibraryDependencies Condition="$(Platform)=='ARM' OR $(Platform)=='x86' OR '$(NDKVersion)' &lt; '17.0'">$(StlLibraryName);android_support;%(LibraryDependencies)</LibraryDependencies>
			<!-- This SO static object file will be moved by the DarkEdifPostBuildTool,
				 so don't confuse VS by building this way. -->
			<IncrementalLink>false</IncrementalLink>
			<!-- Strip out debugger info in release builds. Removes ClCompile.DebuggerSymbolInformation if it's there, too. -->
			<DebuggerSymbolInformation Condition="$(RelBuild)==1">OmitAllSymbolInformation</DebuggerSymbolInformation>
		</Link>
	</ItemDefinitionGroup>
	<!-- Ensure VS knows the build failed if the .so or .zip files weren't updated -->
	<ItemGroup Condition="'$(_TargetPlat)'=='Android'">
		<UpToDateCheckOutput Include="$(MFXDir)\$(ExtName.Replace(' ','_')).zip;$(SolutionDir)\Temp\$(ExtName)\Android\$(Configuration)\$(TargetArch)\lib$(ExtName.Replace(' ','_')).so" />
	</ItemGroup>

<!--#################################
		END Android
		BEGIN iOS
	################################# -->
	<PropertyGroup Condition="$(_TargetPlat)=='iOS'">
		<!-- Always static -->
		<ConfigurationType>StaticLibrary</ConfigurationType>
		<iOSConfigurationType>StaticLibrary</iOSConfigurationType>
		<!-- Debug libraries on Debug config -->
		<UseDebugLibraries>false</UseDebugLibraries>
		<UseDebugLibraries Condition="$(DbgBuild)==1">true</UseDebugLibraries>
		<!-- Most recent supported -->
		<PlatformToolset>XCode_6_1</PlatformToolset>
		<!-- libSTDc++ (not libc++) was deprecated ages ago, and is not available on watchOS or tvOS. -->
		<UseOfStl>libc++</UseOfStl>

		<!-- Targets iPhone simulator. ARM64 can be device or simulator, but VS
			 only appears set up to do device-only ARM64. -->
		<_AppleSDKTarget>iphoneos</_AppleSDKTarget>
		<_AppleSDKTarget Condition="$(MacBuild)==1">macosx</_AppleSDKTarget>
		<_AppleSDKTarget Condition="$(iOSSimulatorBuild)==1">iphonesimulator</_AppleSDKTarget>
		<!-- Override target iOS version; VS defaults to iOS 8.1 and doesn't appear to let you edit it. Note that changing it higher or lower may exclude some CPU archs, exclusion which PostBuildTool is not designed to look for.
			<AppleSDKDeployVersion>11.4</AppleSDKDeployVersion>
		-->

		<!-- iOS files redirection -->
 		<PbxprojDirectory>$(_FusionSDKTempDir)\$(ProjectName).xcodeproj</PbxprojDirectory>
		<PayloadDescriptionFilepath>$(_FusionSDKTempDir)\.$(ProjectName).payload.desc</PayloadDescriptionFilepath>

		<!-- See comments above. -->
		<AppleSDKDeployVersion Condition="$(MacBuild)==0 AND $(ProjectName.StartsWith('Bluewing'))">10.0</AppleSDKDeployVersion>

		<!-- Mac build: minimum possible
		<AppleSDKDeployVersion Condition="$(MacBuild)==1">10.9</AppleSDKDeployVersion> -->

		<!-- We stick with static library default (.a) for iOS, but bundle for Mac -->
		<TargetExt Condition="$(MacBuild)==1">.bundle</TargetExt>

		<!-- Original run of Mac build for CPU arches that VS demands to build with the wrong SDK initially. -->
		<IsSecondRun Condition="'$(IsSecondRun)'==''">0</IsSecondRun>

		<!-- Modifying iOS/Mac projects to fix VS build issues and target specific iOS/Mac versions -->
		<DarkEdifPreBuildToolParams>$(DarkEdifPreBuildToolParams) /DeveloperDir="$(DEVELOPER_DIR)" /AppleSDKTarget="$(_AppleSDKTarget)" /FusionSDKRoot="$(SDKRootFolder)" /PBXPath="$(PbxprojDirectory)\project.pbxproj" /IsSecondRun="$(IsSecondRun)" /ProjConfig="$(Configuration)"</DarkEdifPreBuildToolParams>

		<!-- iOS + Mac build results need copying back from remote folder. -->
		<DarkEdifPostBuildToolParams>$(DarkEdifPostBuildToolParams) /AppleSDKTarget="$(_AppleSDKTarget)"</DarkEdifPostBuildToolParams>
	</PropertyGroup>

	<ItemDefinitionGroup Condition="'$(_TargetPlat)'=='iOS'">
		<ClCompile>
			<PrecompiledHeader>NotUsing</PrecompiledHeader>
			<!-- <AdditionalIncludeDirectories>$(AdditionalIncludeDirectories);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>-->
			<PreprocessorDefinitions>__APPLE__;PROJECT_NAME_RAW=$(ExtName.Replace(' ','_'));%(PreprocessorDefinitions)</PreprocessorDefinitions>
			<!-- Use C++17, and C11, latest finalised standards.
				 VS 2017 (15.0) doesn't understand C++17 as a target for iOS, so we'll add it to additional options manually. -->
			<CppLanguageStandard Condition="$(VisualStudioVersion)&gt;15.0">c++17</CppLanguageStandard>
			<CLanguageStandard>c11</CLanguageStandard>
			<!-- We need C++ exception handling. -->
			<ExceptionHandling>Enabled</ExceptionHandling>
			<!-- Prevents a weird glitch from using structs.
				 Hopefully, also obscures the repeated static library Edif functions from using each others' functions. -->
			<AdditionalOptions>-fsigned-char -fno-aligned-allocation -fvisibility=hidden -Wno-nullability-completeness -D Edif=$(ExtName.Replace(' ','_'))_Edif -D Extension=$(ExtName.Replace(' ','_'))_Extension -D DarkEdif=$(ExtName.Replace(' ','_'))_DarkEdif -D FusionInternals=$(ExtName.Replace(' ','_'))_FusionInternals $(AdditionalOptions)</AdditionalOptions>

			<!-- VS 2017 (15.0) doesn't accept C++17 as a target for iOS, so we'll add it to additional options manually. -->
			<AdditionalOptions Condition="$(VisualStudioVersion)==15.0">-std=c++17 $(AdditionalOptions)</AdditionalOptions>
		</ClCompile>
	</ItemDefinitionGroup>

	<ItemDefinitionGroup Condition="$(_TargetPlat)=='iOS' AND $(DbgBuild)==1">
		<ClCompile>
			<!-- Maximum debug information -->
			<RuntimeTypeInfo>true</RuntimeTypeInfo>
			<GenerateDebugSymbols>true</GenerateDebugSymbols>
			<Optimization>Disabled</Optimization>
			<DebugInformationLevel>Default</DebugInformationLevel>
			<LinkTimeOptimization>false</LinkTimeOptimization>
		</ClCompile>
	</ItemDefinitionGroup>
	<ItemDefinitionGroup Condition="$(_TargetPlat)=='iOS' AND $(DbgBuild)==0">
		<ClCompile>
			<!-- No debugger functionality -->
			<GenerateDebugSymbols>false</GenerateDebugSymbols>
			<DebugInformationLevel>Default</DebugInformationLevel>
			<RuntimeTypeInfo>false</RuntimeTypeInfo>
			<Optimization>Full</Optimization>
			<LinkTimeOptimization Condition="$(LTCG)=='Y'">true</LinkTimeOptimization>
		</ClCompile>
	</ItemDefinitionGroup>
	<!-- Ensure VS knows the build failed if the .xcframework or .ext files weren't updated -->
	<ItemGroup Condition="'$(_TargetPlatInclMac)'=='iOS'">
		<UpToDateCheckOutput Include="$(MFXDir)\$(ExtNameUnderscores).ext;$(SolutionDir)\Temp\$(ExtName)\iOS\$(Configuration)\$(ExtNameUnderscores)).xcframework\Info.plist" />
	</ItemGroup>
	<!-- Ensure VS knows the build failed if the bundle file or .dat file weren't updated -->
	<ItemGroup Condition="'$(_TargetPlatInclMac)'=='Mac'">
		<UpToDateCheckOutput Include="$(MFXDir)\$(ExtName).dat;$(SolutionDir)\Temp\$(ExtName)\Mac\$(Configuration)\$(ExtName)" />
	</ItemGroup>

	<!-- All runtimes -->
	<ItemGroup>
		<!-- Forwards the macros calculated above to the build process -->
		<BuildMacro Include="MFXDir">
			<Value>$(MFXDir)</Value>
		</BuildMacro>
		<BuildMacro Include="UnicodeOrBlank">
			<Value>$(UnicodeOrBlank)</Value>
		</BuildMacro>
		<BuildMacro Include="UniBuild">
			<Value>$(UniBuild)</Value>
		</BuildMacro>
		<BuildMacro Include="ExtName">
			<Value>$(ExtName)</Value>
		</BuildMacro>
		<BuildMacro Include="CompanyName">
			<Value>$(CompanyName)</Value>
		</BuildMacro>
		<BuildMacro Include="Year">
			<Value>$(Year)</Value>
		</BuildMacro>
		<BuildMacro Include="MakePDB">
			<Value>$(MakePDB)</Value>
		</BuildMacro>
		<BuildMacro Include="_FusionSDKAdds">
			<Value>$(_FusionSDKAdds)</Value>
		</BuildMacro>
		<BuildMacro Include="_TargetPlat">
			<Value>$(_TargetPlat)</Value>
		</BuildMacro>
		<BuildMacro Include="IsTemplate">
			<Value>$(IsTemplate)</Value>
		</BuildMacro>
		<BuildMacro Include="SDKType">
			<Value>$(SDKType)</Value>
		</BuildMacro>
		<BuildMacro Include="RunAnalyzerSetting">
			<Value>$(RunAnalyzerSetting)</Value>
		</BuildMacro>
	</ItemGroup>

	<!-- Windows 8.1 SDK misses half its C++ standard library headers if you don't have the Visual Studio Windows Universal CRT SDK component.
		 Windows 10 SDK+ doesn't have this bug.
		 Windows 7.1 SDK from XP targeting pack does have it, but requires Universal CRT SDK as part of XP targeting. -->
	<Target Name="Win8_1 or lower SDK without UCRT" Condition="$(_TargetPlat)==Windows AND $(WindowsTargetPlatformVersion)=='8.1' AND '$(UniversalCRT_IncludePath)'==''" BeforeTargets="ClCompile">
		<Error Text="FusionSDK error: Windows 8.1 or lower SDK cannot work fully without the 'Universal CRT SDK' Visual Studio component." />
	</Target>

	<!-- Windows XP requires VS 2017 (any toolset version) or VS 2019 (specific toolset version). -->
	<Target Name="XP toolset check" Condition="$(WindowsXPCompatibility)==1 AND $(_TargetPlat)=='Windows' AND $(VisualStudioVersion) != 15.0" BeforeTargets="ClCompile;CheckVCToolsetVersion">
		<!-- VS 2017 (15.0) ^ doesn't have any restrictions on toolset version, so no checks are done for it. -->

		<!-- Using VS 2022. -->
		<Error Text="FusionSDK error: You're using XP compatibility - you have to use Visual Studio 2019 or 2017. See the MMF2Exts README.md file." Condition="$(VisualStudioVersion) &gt;= 17.0" />
		<!-- Using VS 2019, but aren't correctly specifying the toolset. This only happens if user manually specifies a toolset too large in their vcxproj/props files. -->
		<Error Text="FusionSDK error: You're using XP compatibility, but not correctly selecting toolset v14.27 or lower. Contact DarkEdif creators." Condition="$(VisualStudioVersion)==16.0 AND $(VCToolsVersion.Replace('.','')) &gt; 142729110" />

		<!-- Using VS 2019, but don't have the XP toolset version. -->
		<Error Text="FusionSDK error: You're using XP compatibility, but you don't have C++ toolset v14.27 or earlier added on your VS setup. See the MMF2Exts README.md file." Condition="$(VisualStudioVersion)==16.0 AND $(VCToolsVersion.Replace('.','')) &lt;= 142729110 AND !Exists('$(VCToolsInstallDir)')" />
	</Target>
	<!-- VS 2017 doesn't support C++17 on Android projects - it does on Windows, and a workaround is used on iOS. -->
	<Target Name="Android on VS 2017 check" Condition="$(_TargetPlat)=='Android' AND $(VisualStudioVersion)==15.0" BeforeTargets="ClCompile;Build">
		<Error Text="FusionSDK error: You cannot use DarkEdif Android builds with VS 2017. VS 2019 is the recommended version."/>
	</Target>

	<!-- Pre build tool for non-Windows. Minifies JSON, and generates a jump function list based on ACE in the Extension.
		 On iOS, Mac, also modifies the generated pbxproj file. -->
	<Target Name="PreBuildTool" Condition="$(SDKType)=='DarkEdif' AND $(RuntimeBuild)==1" BeforeTargets="ClCompile">
		<Message Text="Minifying JSON and checking that ASM/jump table exists for this platform..." Importance="High" />
		<Exec Command="&quot;$(SDKRootFolder)\DarkEdifPreBuildTool.exe&quot; $(DarkEdifPreBuildToolParams)" />
	</Target>

	<!-- Delete output PDB files; they'll either be regenerated by the current build,
		 or they're leftover from the last build config and invalid; e.g. if user does a
		 Debug build then Edittime build, that will result in PDBs that are not applicable
		 to the Edittime build but still in the MFX\Extensions folder. -->
	<Target Name="Delete old PDBs" Condition="$(_TargetPlat)=='Windows'" BeforeTargets="ResourceCompile">
		<Delete Files="$(MFXDir)\$(TargetName).pdb" />
		<Delete Files="$(MFXDir)\$(TargetName)_Full.pdb" />
	</Target>

	<!-- The iOS compiler for some reason insists on using project name instead of target name.
		 We'll temporarily change the project name. Since TargetName includes "lib" and shouldn't, we'll substring it. -->
	<Target Name="iOS library name fix" Condition="$(_TargetPlatInclMac)=='iOS'" BeforeTargets="GenerateXCodeProj">
		<Message Text="Corrected library name from $(ProjectName) to $(TargetName.Substring(3,$([MSBuild]::Subtract($(TargetName.Length), 3))))." Importance="High" />
		<PropertyGroup>
			<ProjectName>$(TargetName.Substring(3,$([MSBuild]::Subtract($(TargetName.Length), 3))))</ProjectName>
 		</PropertyGroup>
	</Target>
	<Target Name="Mac library name fix" Condition="$(_TargetPlatInclMac)=='Mac'" BeforeTargets="GenerateXCodeProj">
		<Message Text="Corrected library name from $(ProjectName) to $(TargetName)." Importance="High" />
		<PropertyGroup>
			<ProjectName>$(TargetName)</ProjectName>
		</PropertyGroup>
	</Target>

	<!-- Obj-C syntax can be permitted on top of C/C++. We want that as Fusion's internals are strictly Obj-C. -->
	<Target Name="iOSAlwaysObjC" Condition="$(_TargetPlat)=='iOS'" BeforeTargets="GenerateXCodeProj">
		<Message Text="FusionProps: overriding CompileAs to include ObjC." Importance="High" />
		<ItemGroup>
			<ClCompile>
				<CompileAs Condition="'%(ClCompile.CompileAs)' == 'CompileAsC'">CompileAsObjC</CompileAs>
				<CompileAs Condition="'%(ClCompile.CompileAs)' == 'CompileAsCpp'">CompileAsObjCpp</CompileAs>
			</ClCompile>
		</ItemGroup>
	</Target>
	
	<!-- After building x86_64, i386, or ARM64, build the Simulator variant of the same.
		 Note that armv7/armv7s are not simulator arches. -->
	<Target Name="iOS build device and simulator together" Condition="'$(_TargetPlatInclMac)'=='iOS' AND $(iOSSimulatorBuild)!=1 AND !$(TargetArch.StartsWith('armv'))" AfterTargets="Build;Rebuild">
		<Message Text="Built device config $(ProjectName), arch $(TargetArch), building simulator variant..." Importance="High" />

		<Message Text="MSBuild project '$(ProjectName)' props='Configuration=$(Configuration);Platform=$(Platform);TargetArch=$(TargetArch);iOSSimulatorBuild=1'" Importance="High" />
		<MSBuild Projects="$(MSBuildProjectFullPath)" Properties="Configuration=$(Configuration);Platform=$(Platform);TargetArch=$(TargetArch);iOSSimulatorBuild=1" Targets="Build" />
	</Target>

	<!-- armv6 is a variant of armv7, in the sense they both use ARM project configuration -->
	<Target Name="iOS Build armv6" Condition="$(_TargetPlatInclMac)=='iOS' AND $(TargetArch)=='armv7' AND $(_iOSBuildArchitectures.Contains('armv6'))" AfterTargets="Build;Rebuild">
		<Message Text="Built device config $(ProjectName), arch $(TargetArch), building armv6 variant..." Importance="High" />

		<Message Text="FusionSDK.props: starting variant MSBuild; project '$(ProjectName)' props='Configuration=$(Configuration);Platform=$(Platform);TargetArch=armv6;PlatformNativeArch=armv6'" Importance="High" />
		<MSBuild Projects="$(MSBuildProjectFullPath)" Properties="Configuration=$(Configuration);Platform=$(Platform);TargetArch=armv6;PlatformNativeArch=armv6" Targets="Build" />
	</Target>

	<!-- armv7s is a variant of armv7 -->
	<Target Name="iOS Build armv7s" Condition="$(_TargetPlatInclMac)=='iOS' AND $(TargetArch)=='armv7' AND $(_iOSBuildArchitectures.Contains('armv7s'))" AfterTargets="Build;Rebuild">
		<Message Text="Built device config $(ProjectName), arch $(TargetArch), building armv7s variant..." Importance="High" />

		<Message Text="FusionSDK.props: starting variant MSBuild; project '$(ProjectName)' props='Configuration=$(Configuration);Platform=$(Platform);TargetArch=armv7s;PlatformNativeArch=armv7s'" Importance="High" />
		<MSBuild Projects="$(MSBuildProjectFullPath)" Properties="Configuration=$(Configuration);Platform=$(Platform);TargetArch=armv7s;PlatformNativeArch=armv7s" Targets="Build" />
	</Target>

	<Target Name="iOS Build arm64e" Condition="$(_TargetPlatInclMac)=='iOS' AND $(TargetArch)=='arm64' AND $(iOSSimulatorBuild)==1 AND $(_iOSBuildArchitectures.Contains('arm64e'))" AfterTargets="Build;Rebuild">
		<Message Text="Built device config $(ProjectName), arch $(TargetArch), building arm64e variant..." Importance="High" />

		<!-- Note: Set SimulatorBuild=0, or it will inherit the =1 from this project run. The above one will also build SimulatorBuild=1 for it. -->
		<Message Text="FusionSDK.props: starting variant MSBuild; project '$(ProjectName)' props='Configuration=$(Configuration);Platform=$(Platform);TargetArch=arm64e;PlatformNativeArch=arm64e;iOSSimulatorBuild=0'" Importance="High" />
		<MSBuild Projects="$(MSBuildProjectFullPath)" Properties="Configuration=$(Configuration);Platform=$(Platform);TargetArch=arm64e;PlatformNativeArch=arm64e;iOSSimulatorBuild=0" Targets="Build" />
	</Target>

	<!-- Post build tool for non-Windows. Copies built libraries into ZIP/EXT in MFX\Data\Runtime. -->
	<Target Name="Copy libraries files into ZIP" Condition="$(SDKType)=='DarkEdif' AND '$(_TargetPlat)'!='Windows' AND '$(IsSecondRun)'!='1'" AfterTargets="Build">
		<Message Text="Copying the built libraries into the $(ZipExt) file in MFX\Data\Runtime..." Importance="High" />
		<Exec Command="&quot;$(SDKRootFolder)\DarkEdifPostBuildTool.exe&quot; $(DarkEdifPostBuildToolParams)" />
	</Target>

	<!-- Writes FusionSDK.props debugging info, usually ext devs should not need this. -->
	<Target Name="For debugging" Condition="$(EchoAllDefinesFromPropsFileDuringBuild)==1" BeforeTargets="ResourceCompile;Compile;Build;BeforeBuild">
		<Message Text="=========================" Importance="High" />
		<Message Text="Echoing #defines from FusionSDK.props:" Importance="High" />
		<Message Text="_FusionSDKAdds = [$(_FusionSDKAdds)]" Importance="High" />
		<Message Text="_FusionSDKAddsRC = [$(_FusionSDKAddsRC)]" Importance="High" />
		<Message Text="=========================" Importance="High" />
	</Target>
</Project>
